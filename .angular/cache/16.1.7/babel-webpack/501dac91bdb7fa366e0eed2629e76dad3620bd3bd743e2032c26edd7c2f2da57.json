{"ast":null,"code":"import _asyncToGenerator from \"C:/jpeg/JPEG_algorithm/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, ViewChild, Component, Output, NgModule } from '@angular/core';\nimport * as i1 from '@angular/common';\nimport { CommonModule } from '@angular/common';\n\n/**\n * EXIF tag standard reference\n *\n * Tag Name: Orientation\n * Tag ID: 0x0112\n * Writable: int16u\n * Group: IFD0\n * Values:\n 1 = Horizontal (normal)\n 2 = Mirror horizontal\n 3 = Rotate 180\n 4 = Mirror vertical\n 5 = Mirror horizontal and rotate 270 CW\n 6 = Rotate 90 CW\n 7 = Mirror horizontal and rotate 90 CW\n 8 = Rotate 270 CW\n */\nconst _c0 = [\"video\"];\nfunction NgxImageCaptureComponent_span_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 2);\n    i0.ɵɵlistener(\"click\", function NgxImageCaptureComponent_span_0_Template_span_click_0_listener() {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r3 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r3.startVideoCapture());\n    });\n    i0.ɵɵprojection(1);\n    i0.ɵɵelementEnd();\n  }\n}\nfunction NgxImageCaptureComponent_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 2);\n    i0.ɵɵlistener(\"click\", function NgxImageCaptureComponent_span_1_Template_span_click_0_listener() {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r5 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r5.acquireImage());\n    });\n    i0.ɵɵprojection(1, 1);\n    i0.ɵɵelementEnd();\n  }\n}\nfunction NgxImageCaptureComponent_video_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"video\", 3, 4);\n  }\n}\nconst _c1 = [[[\"\", \"openStreamBtn\", \"\"]], [[\"\", \"acquireImageBtn\", \"\"]]];\nconst _c2 = [\"[openStreamBtn]\", \"[acquireImageBtn]\"];\nvar DOC_ORIENTATION = /*#__PURE__*/function (DOC_ORIENTATION) {\n  DOC_ORIENTATION[DOC_ORIENTATION[\"Up\"] = 1] = \"Up\";\n  DOC_ORIENTATION[DOC_ORIENTATION[\"Down\"] = 3] = \"Down\";\n  DOC_ORIENTATION[DOC_ORIENTATION[\"Right\"] = 6] = \"Right\";\n  DOC_ORIENTATION[DOC_ORIENTATION[\"Left\"] = 8] = \"Left\";\n  DOC_ORIENTATION[DOC_ORIENTATION[\"UpMirrored\"] = 2] = \"UpMirrored\";\n  DOC_ORIENTATION[DOC_ORIENTATION[\"DownMirrored\"] = 4] = \"DownMirrored\";\n  DOC_ORIENTATION[DOC_ORIENTATION[\"LeftMirrored\"] = 5] = \"LeftMirrored\";\n  DOC_ORIENTATION[DOC_ORIENTATION[\"RightMirrored\"] = 7] = \"RightMirrored\";\n  DOC_ORIENTATION[DOC_ORIENTATION[\"Default\"] = 0] = \"Default\";\n  DOC_ORIENTATION[DOC_ORIENTATION[\"NotJpeg\"] = -1] = \"NotJpeg\";\n  DOC_ORIENTATION[DOC_ORIENTATION[\"NotDefined\"] = -2] = \"NotDefined\";\n  return DOC_ORIENTATION;\n}(DOC_ORIENTATION || {});\nvar _a;\nclass ImageCompress {}\n_a = ImageCompress;\nImageCompress.getOrientation = file => new Promise((resolve, reject) => {\n  try {\n    const reader = new FileReader();\n    reader.onload = () => {\n      const view = new DataView(reader.result);\n      if (!view.byteLength) {\n        return resolve(DOC_ORIENTATION.NotDefined);\n      }\n      if (view.getUint16(0, false) !== 0xffd8) {\n        return resolve(DOC_ORIENTATION.NotDefined);\n      }\n      const length = view.byteLength;\n      let offset = 2;\n      while (offset < length) {\n        const marker = view.getUint16(offset, false);\n        offset += 2;\n        if (marker === 0xffe1) {\n          if (view.getUint32(offset += 2, false) !== 0x45786966) {\n            return resolve(DOC_ORIENTATION.NotJpeg);\n          }\n          const little = view.getUint16(offset += 6, false) === 0x4949;\n          offset += view.getUint32(offset + 4, little);\n          const tags = view.getUint16(offset, little);\n          offset += 2;\n          for (let i = 0; i < tags; i++) {\n            if (view.getUint16(offset + i * 12, little) === 0x0112) {\n              return resolve(view.getUint16(offset + i * 12 + 8, little));\n            }\n          }\n        } else if ((marker & 0xff00) !== 0xff00) {\n          break;\n        } else {\n          offset += view.getUint16(offset, false);\n        }\n      }\n      return resolve(DOC_ORIENTATION.NotJpeg);\n    };\n    reader.readAsArrayBuffer(file);\n  } catch (e) {\n    return reject(DOC_ORIENTATION.Default);\n  }\n});\nImageCompress.uploadFile = (render, multiple = true, rejectOnCancel = false) => new Promise(function (resolve, reject) {\n  const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n  const isIOS = /iPad|iPhone|iPod/i.test(navigator.userAgent);\n  Promise.resolve(isSafari || isIOS).then(onlyNative => {\n    if (onlyNative) {\n      return ImageCompress.generateUploadInputNative(window.document, multiple, rejectOnCancel);\n    } else {\n      return ImageCompress.generateUploadInputRenderer(render, multiple, rejectOnCancel);\n    }\n  }).then(filesList => {\n    const files = filesList ? Array.from(filesList) : [];\n    const orientationPromises = files.map(file => ImageCompress.getOrientation(file));\n    const readerPromises = files.map(file => ImageCompress.fileToDataURL(file));\n    let orientationsResult = [];\n    Promise.all(orientationPromises).then(orientations => {\n      orientationsResult = orientations;\n      return Promise.all(readerPromises);\n    }).then(readerResult => {\n      const resultArray = readerResult.map((parsedFile, index) => ({\n        image: parsedFile.dataUrl,\n        orientation: orientationsResult[index],\n        fileName: parsedFile.fileName\n      }));\n      if (multiple) {\n        resolve(resultArray);\n      } else {\n        resolve(resultArray[0]);\n      }\n    });\n  }).catch(err => reject(err));\n});\nImageCompress.fileToDataURL = file => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      //myReader.onloadend = (progressEvent: ProgressEvent<FileReader>)\n      resolve({\n        dataUrl: e.target.result,\n        fileName: file.name\n      });\n    };\n    try {\n      reader.readAsDataURL(file);\n    } catch (e) {\n      reject(`ngx-image-compress - probably no file have been selected: ${e}`);\n    }\n  });\n};\nImageCompress.generateUploadInputRenderer = (render, multiple = true, rejectOnCancel = false) => {\n  let lock = false;\n  return new Promise((resolve, reject) => {\n    const inputElement = render.createElement('input');\n    render.setStyle(inputElement, 'display', 'none');\n    render.setProperty(inputElement, 'type', 'file');\n    render.setProperty(inputElement, 'accept', 'image/*');\n    if (multiple) {\n      render.setProperty(inputElement, 'multiple', 'true');\n    }\n    render.listen(inputElement, 'click', $event => {\n      $event.target.value = '';\n    });\n    render.listen(inputElement, 'change', $event => {\n      lock = true;\n      const files = $event.target.files;\n      resolve(files);\n    });\n    if (rejectOnCancel) {\n      window.addEventListener('focus', () => {\n        setTimeout(() => {\n          if (!lock) {\n            reject(new Error('file upload on blur - no file selected'));\n          }\n        }, 300);\n      }, {\n        once: true\n      });\n    }\n    inputElement.click();\n  });\n};\nImageCompress.generateUploadInputNative = (documentNativeApi, multiple = true, rejectOnCancel = false) => {\n  let lock = false;\n  return new Promise((resolve, reject) => {\n    const inputElement = documentNativeApi.createElement('input');\n    inputElement.id = 'upload-input' + new Date();\n    inputElement.style.display = 'none';\n    inputElement.setAttribute('type', 'file');\n    inputElement.setAttribute('accept', 'image/*');\n    if (multiple) {\n      inputElement.setAttribute('multiple', 'true');\n    }\n    documentNativeApi.body.appendChild(inputElement);\n    inputElement.addEventListener('change', () => {\n      lock = true;\n      resolve(inputElement.files);\n      documentNativeApi.body.removeChild(documentNativeApi.getElementById(inputElement.id));\n    }, {\n      once: true\n    });\n    if (rejectOnCancel) {\n      window.addEventListener('focus', () => {\n        setTimeout(() => {\n          if (!lock && documentNativeApi.getElementById(inputElement.id)) {\n            reject(new Error('file upload on blur - no file selected'));\n            documentNativeApi.body.removeChild(documentNativeApi.getElementById(inputElement.id));\n          }\n        }, 300);\n      }, {\n        once: true\n      });\n    }\n    // open file select box\n    inputElement.click();\n  });\n};\nImageCompress.compress = (imageDataUrlSource, orientation, render, ratio = 50, quality = 50, maxwidth = 0, maxheight = 0) => new Promise(function (resolve, reject) {\n  quality = quality / 100;\n  ratio = ratio / 100;\n  const sourceImage = new Image();\n  // important for safari: we need to wait for onload event\n  sourceImage.onload = () => {\n    const canvas = render.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n      return reject(`No canvas context available`);\n    }\n    let w = sourceImage.naturalWidth;\n    let h = sourceImage.naturalHeight;\n    if (!CSS.supports('image-orientation', 'from-image')) {\n      if (orientation === DOC_ORIENTATION.Right || orientation === DOC_ORIENTATION.Left) {\n        const t = w;\n        w = h;\n        h = t;\n      }\n    }\n    const xratio = maxwidth ? maxwidth / w : 1;\n    const yratio = maxheight ? maxheight / h : 1;\n    ratio = Math.min(ratio, xratio, yratio);\n    canvas.width = w * ratio;\n    canvas.height = h * ratio;\n    const TO_RADIANS = Math.PI / 180;\n    if (CSS.supports('image-orientation', 'from-image') || orientation === DOC_ORIENTATION.Up) {\n      ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);\n    } else if (orientation === DOC_ORIENTATION.Right) {\n      ctx.save();\n      ctx.rotate(90 * TO_RADIANS);\n      ctx.translate(0, -canvas.width);\n      ctx.drawImage(sourceImage, 0, 0, canvas.height, canvas.width);\n      ctx.restore();\n    } else if (orientation === DOC_ORIENTATION.Left) {\n      ctx.save();\n      ctx.rotate(-90 * TO_RADIANS);\n      ctx.translate(-canvas.width, 0);\n      ctx.drawImage(sourceImage, 0, 0, canvas.height, canvas.width);\n      ctx.restore();\n    } else if (orientation === DOC_ORIENTATION.Down) {\n      ctx.save();\n      ctx.rotate(180 * TO_RADIANS);\n      ctx.translate(-canvas.width, -canvas.height);\n      ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);\n      ctx.restore();\n    } else {\n      // no orientation value found - same as default UP\n      ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);\n    }\n    const mime = imageDataUrlSource.substr(5, imageDataUrlSource.split(';')[0].length - 5);\n    // TODO test on mime\n    const result = canvas.toDataURL(mime, quality);\n    resolve(result);\n  };\n  sourceImage.onerror = e => reject(e);\n  sourceImage.src = imageDataUrlSource;\n});\nImageCompress.byteCount = imgString => encodeURI(imgString).split(/%..|./).length - 1;\nImageCompress.getImageMaxSize = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (maxSizeMb, debugMode, render, rejectOnCancel = false) {\n    const MAX_TRIES = 10;\n    const bytesToMB = bytes => (bytes / 1024 / 1024).toFixed(2);\n    if (debugMode) {\n      console.debug('NgxImageCompress - Opening upload window');\n    }\n    const myFile = yield ImageCompress.uploadFile(render, false, rejectOnCancel);\n    let compressedFile;\n    for (let i = 0; i < MAX_TRIES; i++) {\n      const previousSize = ImageCompress.byteCount(myFile.image);\n      compressedFile = yield ImageCompress.compress(myFile.image, myFile.orientation, render, 50, 100);\n      const newSize = ImageCompress.byteCount(compressedFile);\n      console.debug('NgxImageCompress -', 'Compression from', bytesToMB(previousSize), 'MB to', bytesToMB(newSize), 'MB');\n      if (newSize >= previousSize) {\n        if (i === 0) {\n          if (debugMode) {\n            console.debug('NgxImageCompress -', \"File can't be reduced at all - returning the original\", bytesToMB(previousSize), 'MB large');\n          }\n          throw {\n            ...myFile,\n            image: compressedFile\n          };\n        } else {\n          if (debugMode) {\n            console.debug('NgxImageCompress -', \"File can't be reduced more - returning the best we can, which is \", bytesToMB(previousSize), 'MB large');\n          }\n          throw {\n            ...myFile,\n            image: compressedFile\n          };\n        }\n      } else {\n        if (newSize < maxSizeMb * 1024 * 1024) {\n          if (debugMode) {\n            console.debug('NgxImageCompress -', 'Here your file', bytesToMB(newSize), 'MB large');\n          }\n          return {\n            ...myFile,\n            image: compressedFile\n          };\n        } else if (i === 9) {\n          if (debugMode) {\n            console.debug('NgxImageCompress -', \"File can't reach the desired size after\", MAX_TRIES, 'tries. Returning file ', bytesToMB(previousSize), 'MB large');\n          }\n          throw {\n            ...myFile,\n            image: compressedFile\n          };\n        }\n      }\n      if (debugMode) {\n        console.debug('NgxImageCompress -', 'Reached', bytesToMB(newSize), 'MB large. Trying another time after', i + 1, 'times');\n      }\n      myFile.image = compressedFile;\n    }\n    if (debugMode) {\n      console.debug('NgxImageCompress - Unexpected error');\n    }\n    throw {};\n  });\n  return function (_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\nlet NgxImageCompressService = /*#__PURE__*/(() => {\n  class NgxImageCompressService {\n    constructor(rendererFactory) {\n      this.DOC_ORIENTATION = DOC_ORIENTATION;\n      this.render = rendererFactory.createRenderer(null, null);\n    }\n    /**\n     * helper to evaluate the compression rate\n     * @param imgString the image in base64 string format\n     */\n    byteCount(image) {\n      return ImageCompress.byteCount(image);\n    }\n    /**\n     * Get the correct Orientation value from image tags\n     */\n    getOrientation(file) {\n      return ImageCompress.getOrientation(file);\n    }\n    /**\n     * return a promise with the new image data and image orientation\n     * Nothing happen if no file have been selected\n     */\n    uploadFile() {\n      return ImageCompress.uploadFile(this.render, false);\n    }\n    /**\n     * return a promise with an array of image data and image orientation\n     * Nothing happen if no files have been selected\n     */\n    uploadMultipleFiles() {\n      return ImageCompress.uploadFile(this.render, true);\n    }\n    /**\n     * return a promise with the new image data and image orientation\n     * the promise will reject if no file have been selected\n     */\n    uploadFileOrReject() {\n      return ImageCompress.uploadFile(this.render, false, true);\n    }\n    /**\n     * return a promise with an array of image data and image orientation\n     * the promise will reject if no files have been selected\n     */\n    uploadMultipleFilesOrReject() {\n      return ImageCompress.uploadFile(this.render, true, true);\n    }\n    /**\n    * perform a compression from the given DataUrl (string), provided by the uploadFile, or uploadMultipleFiles method\n    *\n    *\n    | Parameter   | Type   | Description                                                                       |\n    | ----------- | ------ | --------------------------------------------------------------------------------- |\n    | image       | string | DataUrl (string) representing the image                                           |\n    | orientation | number | EXIF Orientation value using the DOC_ORIENTATION enum value                       |\n    | ratio       | number | Maximum scale factor as a percentage (optional, default: 50) <sup>[1](#fn1)</sup> |\n    | quality     | number | JPEG quality factor as a percentage (optional, default: 50) <sup>[2](#fn2)</sup>  |\n    | maxwidth    | number | Maximum width in pixels if you need to resize (optional, default: 0 - no resize)  |\n    | maxheight   | number | Maximum height in pixels if you need to resize (optional, default: 0 - no resize) |\n    */\n    compressFile(image, orientation, ratio = 50, quality = 50, maxWidth = 0, maxHeight = 0) {\n      return ImageCompress.compress(image, orientation, this.render, ratio, quality, maxWidth, maxHeight);\n    }\n    /**\n     * Most simple function to use here.\n     * Perform an upload and return an image dataUrl (string format) with a maximum size, given in *MegaBytes*\n     * If the size can't be reached, the best that can be reached will be returned in promise *rejection*\n     * Put debugMode to true if you have some trouble to print some help using console.debug\n     */\n    uploadAndGetImageWithMaxSize(maxSizeMb = 1, debugMode = false, rejectOnCancel = false) {\n      return ImageCompress.getImageMaxSize(maxSizeMb, debugMode, this.render, rejectOnCancel).then(uploadResponse => uploadResponse.image).catch(e => {\n        throw e.image;\n      });\n    }\n    /**\n     * Same as before, but return more informations (file name...)\n     */\n    uploadAndGetImageWithMaxSizeAndMetas(maxSizeMb = 1, debugMode = false, rejectOnCancel = false) {\n      return ImageCompress.getImageMaxSize(maxSizeMb, debugMode, this.render, rejectOnCancel);\n    }\n  }\n  NgxImageCompressService.ɵfac = function NgxImageCompressService_Factory(t) {\n    return new (t || NgxImageCompressService)(i0.ɵɵinject(i0.RendererFactory2));\n  };\n  NgxImageCompressService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NgxImageCompressService,\n    factory: NgxImageCompressService.ɵfac,\n    providedIn: 'root'\n  });\n  return NgxImageCompressService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgxImageCaptureComponent = /*#__PURE__*/(() => {\n  class NgxImageCaptureComponent {\n    constructor() {\n      this.imageCaptured = new EventEmitter();\n      this.errorCapture = new EventEmitter();\n      this.videoElement = null;\n      this.videoStream = ViewChild('video');\n      this.streamOpened = false;\n    }\n    startVideoCapture() {\n      this.streamOpened = true;\n      const constraints = {\n        audio: false,\n        video: {\n          width: {\n            ideal: 1920\n          },\n          height: {\n            ideal: 1080\n          },\n          facingMode: {\n            ideal: 'user'\n          }\n        }\n      };\n      navigator.mediaDevices.getUserMedia(constraints).then(stream => {\n        this.videoStream = stream;\n        setTimeout(() => {\n          if (this.videoElement?.nativeElement) {\n            this.videoElement.nativeElement.srcObject = stream;\n          }\n        }, 100);\n      }).catch(error => {\n        this.errorCapture.emit(`Ngx Image Compress: Could not access the camera. ${error}`);\n        this.streamOpened = true;\n      });\n    }\n    acquireImage() {\n      const canvas = document.createElement('canvas');\n      const video = this.videoElement?.nativeElement;\n      if (!video) {\n        this.errorCapture.emit('Ngx Image Compress - Error in acquisition of video element.');\n        this.streamOpened = false;\n        return;\n      }\n      canvas.width = video.videoWidth;\n      canvas.height = video.videoHeight;\n      canvas.getContext('2d')?.drawImage(video, 0, 0);\n      const newImage = canvas.toDataURL('jpg', 95);\n      if (this.videoStream) {\n        this.videoStream.getVideoTracks().forEach(track => track.stop());\n      }\n      this.imageCaptured.emit(newImage);\n      this.streamOpened = false;\n    }\n  }\n  NgxImageCaptureComponent.ɵfac = function NgxImageCaptureComponent_Factory(t) {\n    return new (t || NgxImageCaptureComponent)();\n  };\n  NgxImageCaptureComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NgxImageCaptureComponent,\n    selectors: [[\"ngx-image-capture\"]],\n    viewQuery: function NgxImageCaptureComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.videoElement = _t.first);\n      }\n    },\n    outputs: {\n      imageCaptured: \"imageCaptured\",\n      errorCapture: \"errorCapture\"\n    },\n    ngContentSelectors: _c2,\n    decls: 3,\n    vars: 3,\n    consts: [[3, \"click\", 4, \"ngIf\"], [\"autoplay\", \"\", 4, \"ngIf\"], [3, \"click\"], [\"autoplay\", \"\"], [\"video\", \"\"]],\n    template: function NgxImageCaptureComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c1);\n        i0.ɵɵtemplate(0, NgxImageCaptureComponent_span_0_Template, 2, 0, \"span\", 0);\n        i0.ɵɵtemplate(1, NgxImageCaptureComponent_span_1_Template, 2, 0, \"span\", 0);\n        i0.ɵɵtemplate(2, NgxImageCaptureComponent_video_2_Template, 2, 0, \"video\", 1);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", !ctx.streamOpened);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.streamOpened);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.streamOpened);\n      }\n    },\n    dependencies: [i1.NgIf],\n    encapsulation: 2\n  });\n  return NgxImageCaptureComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgxImageCaptureModule = /*#__PURE__*/(() => {\n  class NgxImageCaptureModule {}\n  NgxImageCaptureModule.ɵfac = function NgxImageCaptureModule_Factory(t) {\n    return new (t || NgxImageCaptureModule)();\n  };\n  NgxImageCaptureModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxImageCaptureModule\n  });\n  NgxImageCaptureModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return NgxImageCaptureModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Public API Surface of ngx-image-compress\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DOC_ORIENTATION, NgxImageCaptureComponent, NgxImageCaptureModule, NgxImageCompressService };\n//# sourceMappingURL=ngx-image-compress.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}